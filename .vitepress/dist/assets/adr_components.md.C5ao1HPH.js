import{_ as e,c as o,o as t,a3 as n}from"./chunks/framework.Bsyxd66g.js";const f=JSON.parse('{"title":"200 Components","description":"","frontmatter":{},"headers":[],"relativePath":"adr/components.md","filePath":"adr/components.md"}'),a={name:"adr/components.md"},s=n('<h1 id="_200-components" tabindex="-1">200 Components <a class="header-anchor" href="#_200-components" aria-label="Permalink to &quot;200 Components&quot;">​</a></h1><p>In Angular, components represent areas of user interface. As such, they are a <em>primary</em> focus of our work.</p><h2 id="_201-decision-use-standalone-components" tabindex="-1">201 Decision: Use Standalone Components <a class="header-anchor" href="#_201-decision-use-standalone-components" aria-label="Permalink to &quot;201 Decision: Use Standalone Components&quot;">​</a></h2><p>Historically, at least since soon after Angular 2 shipped, components had to be part of an abstraction called an <em>Angular Module</em>. The <code>NgModule</code> would declare all the related components, as well as services, for an area of your application. Each Angular application would have at least one <code>NgModule</code> (usually defined in the <code>app.module.ts</code>). Other modules could be created to encompass other semi-isolated</p><p>They would be imported into the module&#39;s list of components and would be ambiently available to every other component that was part of that module in that the component&#39;s template would recognize the imported components <em>selector</em>. The &quot;<em>ambiently available</em>&quot; part was the magic. In a properly configured Angular application, the &quot;on-ramp&quot; was easier - you didn&#39;t have to remember to include imported components, directives, etc. in <em>each</em> component.</p><p>There are a couple of problems with this approach, however. &quot;Magic&quot; always comes with a price. A technical issue is that using modules does not allow for a fine level of &quot;tree-shaking&quot; when compiling, resulting in larger bundle sizes. A common practice for many Angular developers was to create &quot;Single Component Modules&quot; to allow for things like lazy-loading.</p><p>The problems were most in-the-face of developers when writing tests for components. You simply could not look at the component source code and determine the dependencies. You&#39;d also have to look at the module.</p><p><em>Modern</em> Angular (v16) introduced the idea of <em>Standalone Components</em>. These components do <em>not</em> belong to a particular module.</p><p>Standalone components declare all their dependencies, handle lazy-loading appropriately, and are much cleaner and easier to work with, despite a slight increase in &quot;import&quot; noise.</p><h2 id="_202-decision-prefer-inline-templates-and-inline-styles" tabindex="-1">202 Decision: Prefer Inline Templates and Inline Styles <a class="header-anchor" href="#_202-decision-prefer-inline-templates-and-inline-styles" aria-label="Permalink to &quot;202 Decision: Prefer Inline Templates and Inline Styles&quot;">​</a></h2><p>This is not a hard rule, but is included here because using inline styles and inline templates in your components is a good way to push developers to a best practice, namely <strong>Components Should Be Small and Focused</strong>.</p><p>Using the <code>template:</code> property instead of the <code>templateUrl:</code> property (and associated properties for styles) within components essentially does the same thing. If you use URLs, during compilation, those resources are <em>inlined</em> in your code.</p>',12),i=[s];function l(r,d,c,p,m,u){return t(),o("div",null,i)}const g=e(a,[["render",l]]);export{f as __pageData,g as default};
